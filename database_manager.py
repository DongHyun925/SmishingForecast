# -*- coding: utf-8 -*-
"""Database Manager

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TpR8AfSKTFwZoNDniVUO7-Dnfun1CYQg
"""

import os
import sqlite3
import json
from datetime import datetime
from dotenv import load_dotenv

# Supabase는 선택적 의존성 (없어도 SQLite 모드로 동작)
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False
    Client = None  # 타입 힌트용 더미

# 환경 변수(.env) 로드
load_dotenv()

class DBManager:
    """
    [DB Manager Class]
    SQLite(로컬)와 Supabase(클라우드)를 동시에 지원하는 데이터베이스 연결 관리자.
    환경 변수에 따라 자동으로 모드를 전환합니다.
    """

    def __init__(self, db_path="smishing_db.db"):
        self.mode = 'sqlite'  # 기본 모드: 로컬 SQLite
        self.supabase: Client = None
        self.sqlite_path = db_path

        # 1. Supabase 연결 시도 (클라우드 모드)
        sb_url = os.getenv("SUPABASE_URL")
        sb_key = os.getenv("SUPABASE_KEY")

        if SUPABASE_AVAILABLE and sb_url and sb_key and "your-project" not in sb_url:
            try:
                self.supabase = create_client(sb_url, sb_key)
                self.mode = 'supabase'
                print(f"[System] Supabase Connected: {sb_url}")
            except Exception as e:
                print(f"[Warning] Supabase Connection Failed: {e}")
                self._init_sqlite() # 실패 시 SQLite로 폴백(Fallback)
        else:
            print("[System] Running in Local SQLite Mode")
            self._init_sqlite()

    def _init_sqlite(self):
        """
        [SQLite 초기화]
        로컬 DB 파일에 필요한 테이블이 없으면 생성합니다.
        """
        self.conn = sqlite3.connect(self.sqlite_path, check_same_thread=False)
        self.cursor = self.conn.cursor()

        # 1. 시나리오(Intents) 테이블
        # 공격 유형과 심리적 트리거 정보를 저장합니다.
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS intents (
                id TEXT PRIMARY KEY,
                intent_name TEXT,
                description TEXT,
                category TEXT,
                metadata TEXT, -- JSON 문자열로 저장
                last_updated TEXT
            )
        ''')

        # 2. 공격 로그(Attack Logs) 테이블
        # 생성된 공격 문구와 방어 모델의 점수를 기록합니다.
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS attack_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scenario_name TEXT,
                generated_msg TEXT,
                score REAL,
                model_used TEXT,
                timestamp TEXT
            )
        ''')

        # 3. 원본 데이터셋(Raw Datasets) 테이블
        # 학습에 사용된 원본 데이터를 저장합니다.
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS raw_datasets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                source_file TEXT,
                content TEXT,
                full_json TEXT, -- JSON 문자열
                ingested_at TEXT
            )
        ''')

        # 4. 뉴스 기사(Context) 테이블 - [NEW]
        # 공격 시나리오의 기반이 되는 뉴스 데이터를 저장합니다.
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS news_articles (
                id TEXT PRIMARY KEY, -- 뉴스 URL 또는 고유 ID
                news_title TEXT,
                news_content TEXT,
                source_date TEXT,
                category TEXT,
                original_json TEXT, -- 원본 JSON 보존
                saved_at TEXT
            )
        ''')

        # 5. 보안 리포트(Security Reports) 테이블 - [NEW]
        # 생성된 보안 분석 리포트를 저장합니다.
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS security_reports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scenario_name TEXT,
                news_title TEXT,
                report_text TEXT, -- 마크다운 텍스트
                pdf_data BLOB, -- PDF 바이너리 데이터
                created_at TEXT
            )
        ''')
        self.conn.commit()

    # --- Public Methods (Common Interface) ---

    def insert_log(self, log_data: dict):
        """
        [로그 저장]
        생성된 스미싱 문자와 탐지 결과를 저장합니다.
        """
        timestamp = datetime.now().isoformat()

        if self.mode == 'supabase':
            # Supabase API 사용 (JSON 데이터 직접 전송)
            data = {**log_data, "timestamp": timestamp}
            self.supabase.table('attack_logs').insert(data).execute()
        else:
            # SQLite Query 실행
            self.cursor.execute(
                "INSERT INTO attack_logs (scenario_name, generated_msg, score, model_used, timestamp) VALUES (?, ?, ?, ?, ?)",
                (log_data.get('scenario_name'), log_data.get('generated_msg'), log_data.get('score'), log_data.get('model_used'), timestamp)
            )
            self.conn.commit()

    def upsert_intent(self, intent_data: dict):
        """
        [시나리오 동기화]
        기존에 있으면 업데이트, 없으면 삽입 (Upsert)
        """
        timestamp = datetime.now().isoformat()

        if self.mode == 'supabase':
            data = {**intent_data, "last_updated": timestamp}
            self.supabase.table('intents').upsert(data).execute()
        else:
            # SQLite에서는 JSON 필드를 문자열로 변환해야 함
            meta_str = json.dumps(intent_data.get('metadata', {}), ensure_ascii=False)
            self.cursor.execute(
                "INSERT OR REPLACE INTO intents (id, intent_name, description, category, metadata, last_updated) VALUES (?, ?, ?, ?, ?, ?)",
                (intent_data['id'], intent_data['intent_name'], intent_data['description'], intent_data['category'], meta_str, timestamp)
            )
            self.conn.commit()

    def insert_dataset_bulk(self, data_list: list):
        """
        [대량 데이터 저장]
        학습 데이터를 한 번에 저장합니다. (Batch Insert)
        """
        if not data_list: return

        if self.mode == 'supabase':
            try:
                # Supabase Upsert (중복 방지 설정 필요)
                self.supabase.table('raw_datasets').upsert(data_list, on_conflict='source_file, content').execute()
            except Exception as e:
                print(f"[DB Error] Supabase Bulk Insert Failed: {e}")
        else:
            try:
                # SQLite Executemany (고속 삽입)
                self.cursor.executemany(
                    "INSERT INTO raw_datasets (source_file, content, full_json) VALUES (:source_file, :content, :full_json)",
                    data_list
                )
                self.conn.commit()
            except Exception as e:
                print(f"[DB Error] SQLite Bulk Insert Failed: {e}")

    def insert_news(self, news_item: dict):
        """
        [뉴스 기사 저장]
        크롤링된 뉴스 데이터를 DB에 저장합니다.
        Key: news_item['context']['url'] (없으면 title+date 해시 사용)
        """
        if not news_item or 'context' not in news_item: return
        
        ctx = news_item['context']
        news_id = ctx.get('url', f"{ctx.get('news_title')}_{ctx.get('source_date')}")
        saved_at = datetime.now().isoformat()
        
        # 원본 JSON 저장
        original_json = json.dumps(news_item, ensure_ascii=False)
        
        if self.mode == 'supabase':
            data = {
                "id": news_id,
                "news_title": ctx.get('news_title'),
                "news_content": ctx.get('news_content')[:], # 전체 저장
                "source_date": ctx.get('source_date'),
                "category": ctx.get('category'),
                "original_json": original_json,
                "saved_at": saved_at
            }
            try:
                self.supabase.table('news_articles').upsert(data).execute()
            except Exception as e:
                print(f"[DB Error] Supabase News Insert Failed: {e}")
        else:
            try:
                self.cursor.execute(
                    """
                    INSERT OR IGNORE INTO news_articles 
                    (id, news_title, news_content, source_date, category, original_json, saved_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                    """,
                    (news_id, ctx.get('news_title'), ctx.get('news_content'), ctx.get('source_date'), ctx.get('category'), original_json, saved_at)
                )
                self.conn.commit()
            except Exception as e:
                print(f"[DB Error] SQLite News Insert Failed: {e}")

    def insert_report(self, report_data: dict):
        """
        [보안 리포트 저장]
        생성된 보안 분석 리포트를 DB에 저장합니다.
        report_data: {
            'scenario_name': str,
            'news_title': str,
            'report_text': str (markdown),
            'pdf_data': bytes
        }
        """
        if not report_data: return
        
        created_at = datetime.now().isoformat()
        
        if self.mode == 'supabase':
            # Supabase는 BLOB 대신 Base64 인코딩 필요
            import base64
            pdf_b64 = base64.b64encode(report_data.get('pdf_data', b'')).decode('utf-8') if report_data.get('pdf_data') else None
            
            data = {
                "scenario_name": report_data.get('scenario_name'),
                "news_title": report_data.get('news_title'),
                "report_text": report_data.get('report_text'),
                "pdf_data": pdf_b64,
                "created_at": created_at
            }
            try:
                self.supabase.table('security_reports').insert(data).execute()
            except Exception as e:
                print(f"[DB Error] Supabase Report Insert Failed: {e}")
        else:
            try:
                self.cursor.execute(
                    """
                    INSERT INTO security_reports 
                    (scenario_name, news_title, report_text, pdf_data, created_at)
                    VALUES (?, ?, ?, ?, ?)
                    """,
                    (
                        report_data.get('scenario_name'),
                        report_data.get('news_title'),
                        report_data.get('report_text'),
                        report_data.get('pdf_data'),  # BLOB으로 직접 저장
                        created_at
                    )
                )
                self.conn.commit()
            except Exception as e:
                print(f"[DB Error] SQLite Report Insert Failed: {e}")

    def get_stats(self):
        """
        [통계 조회]
        대시보드에 표시할 데이터 개수를 반환합니다.
        """
        stats = {'mode': self.mode}

        if self.mode == 'supabase':
            try:
                # count='exact', head=True: 데이터 없이 개수만 빠르게 조회
                stats['logs'] = self.supabase.table('attack_logs').select('*', count='exact', head=True).execute().count
                stats['intents'] = self.supabase.table('intents').select('*', count='exact', head=True).execute().count
            except:
                stats['logs'] = 0
                stats['intents'] = 0
        else:
            stats['logs'] = self.cursor.execute("SELECT COUNT(*) FROM attack_logs").fetchone()[0]
            stats['intents'] = self.cursor.execute("SELECT COUNT(*) FROM intents").fetchone()[0]

        return stats

    def close(self):
        """
        [연결 종료]
        SQLite 연결을 안전하게 닫습니다.
        """
        if self.mode == 'sqlite' and self.conn:
            self.conn.close()